'''
提供一个move到目标坐标的方法move_to.最大纵向速度1.6，最大横移速度0.55， 最大角速度2.5.
注意必须输入浮点数
'''
import rclpy
import math
from rclpy.node import Node
from protocol.msg import MotionServoCmd
import threading
import time
from .data_receive import get_dog_address
from .stop_node import StopNode
from .socket import SocketReciv

class moveto(Node):
    def __init__(self,name,goal_coords,socket):
        super().__init__(name)
        self.motion_id = 303
        self.speed_x, self.speed_y, self.speed_z = 0.0, 0.0, 0.0
        self.dog_name = "az"
        self.pub = self.create_publisher(MotionServoCmd, f"/{self.dog_name}/motion_servo_cmd", 10)
        self.timer = self.create_timer(0.1, self.timer_callback)
        self.arrived=False
        self.max_speed_x = 0.65
        self.max_speed_y = 0.3
        self.max_speed_z = 1.25
        self.goal_address = goal_coords
        self.socket = socket

    def timer_callback(self):
        _, dog_coords, _ = self.socket.get_data()
        delta_x = self.goal_address[0] - dog_coords[0]
        delta_y = self.goal_address[1] - dog_coords[1]
        speed_ratio = delta_y / delta_x if delta_x != 0 else float('inf')
        if dist(dog_coords,self.goal_address)>0.2:#如果没到，那么进行下一步
            if abs(speed_ratio) <= self.max_speed_x / self.max_speed_y:
            # 斜率小于最大允许斜率时，使用比例速度
                if delta_x>0:#目标点在狗的右边
                    self.speed_y = -0.3
                else :
                    self.speed_y = 0.3
                self.speed_x = -speed_ratio * self.speed_y
            elif abs(speed_ratio) <=6.5:#如果斜率大于最大允许斜率，但小于6.5，这说明狗和目标位置的横向距离已经足够接近
                if delta_x>0:#目标点在狗的右边
                    self.speed_y = -0.1
                else :
                    self.speed_y = 0.1
                self.speed_x = -speed_ratio * self.speed_y
            else:
                if delta_y>0:#目标点在狗的前方
                    self.speed_x=0.5
                else:
                    self.speed_x=-0.5
                self.speed_y=0.0
            
        else:
            self.arrived=True
            self.speed_x, self.speed_y, self.speed_z = 0.0, 0.0, 0.0
            
        self.get_logger().info(f"from {dog_coords}moving to {self.goal_address}")
        msg = MotionServoCmd()
        msg.motion_id = self.motion_id
        msg.cmd_type = 1
        msg.value = 2
        msg.vel_des = [self.speed_x, self.speed_y, self.speed_z]
        msg.step_height = [0.05,0.05]
        self.pub.publish(msg)



# def IsArrived(self,goal_coords):
#         _, dog_coords, _ = self.socket.get_data()
#         target_dist =dist(goal_coords,dog_coords)
#         if target_dist<0.2:#距离小于0.5视为到达
#             return True
#         else:
#             return False

def dist(point1, point2):
        distance = math.sqrt((point2[0]-point1[0])**2 + (point2[1]-point1[1])**2)
        return distance

def move_to(goal_address,socket):
    rclpy.init(args=None)
    moveto_node=moveto("moveto_node",goal_address,socket)

    stop_node = StopNode("stop_node")

    moveto_thread=threading.Thread(target=rclpy.spin,args=(moveto_node,))
    moveto_thread.start()
    while not moveto_node.arrived:
        pass

    stop_thread = threading.Thread(target=rclpy.spin, args=(stop_node,))
    stop_thread.start()
    time.sleep(0.1)
    stop_node.destroy_node()

    moveto_node.destroy_node()
    rclpy.shutdown()
    return True


def main(args=None):  # 将目标位置作为参数
    s = SocketReciv()
    move_to([0.5, 6.1], s)
    move_to([-0.5, 6.1], s)
    move_to([0.5, 3.1], s)
    del s


if __name__ == "__main__":
    main()  # 传递目标位置